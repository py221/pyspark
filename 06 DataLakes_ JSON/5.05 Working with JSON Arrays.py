# Databricks notebook source
# MAGIC %md 
# MAGIC ###JSON: Working with JSON Arrays
# MAGIC 
# MAGIC **Objective:** The objective of this lab is to teach you how to work with JSON arrays.

# COMMAND ----------

# MAGIC %md As mentioned in an earlier lab, data in a JSON document is encapsulated as a structure containing one or more key-value pairs and/or as an ordered data set as an array of values.  Up to now, we have focused on JSON documents focused exclusively on key-value pairs.  Now, we will look at a dataset making heavy use of an array.
# MAGIC 
# MAGIC The data set we will work with comes from the New York City CitiBikes program.  You can read more about the data sets avaialble from this program at https://www.citibikenyc.com/system-data.
# MAGIC 
# MAGIC The specific data feed we will access is the Station feed found at https://feeds.citibikenyc.com/stations/stations.json. Information about this and other near real-time feeds of data from the NY CitiBikes program can be found here: https://github.com/NABSA/gbfs/blob/master/gbfs.md
# MAGIC 
# MAGIC To get started, let's retrieve data from the NYC CitiBikes website, send it to an RDD, and then convert that RDD to a dataframe, having Spark infer the structure for us.  Let's create a temp view from this data set to enable later queries:

# COMMAND ----------

from urllib import request as url 

# retrieve json data from website
request = url.Request('https://feeds.citibikenyc.com/stations/stations.json')
response = url.urlopen(request)

# convert to rdd (making sure to convert bytes to UTF-8 string)
json_rdd = sc.parallelize( [response.read().decode('utf-8').strip()] )

# convert rdd to dataframe
stations = spark.read.json( json_rdd )
stations.createOrReplaceTempView('stations')

stations.printSchema()

# COMMAND ----------

# MAGIC %md From the schema information provided, you can see that there are two key-value pairs off the root of this document: executionTime and stationBeanList. executionTime is the point in time at which the dataset was last updated. stationBeanList is an array of structures.  Each structure provides the data for a single station:

# COMMAND ----------

# %sql 

# select 
#     a.executionTime,
#     a.stationBeanList
# from stations a

# COMMAND ----------

# MAGIC %md Our challenge is how to access the data in the stationBeanList array. Using the inline function, we can grab an array, converting each item in the array into a row in our result set. Parent and sibling values associated with the array are joined to each of these new rows generated by this function, preserving the integrity of the data associations.

# COMMAND ----------

# MAGIC %sql 
# MAGIC 
# MAGIC select 
# MAGIC     a.executionTime,
# MAGIC     inline(a.stationBeanList)
# MAGIC from stations a

# COMMAND ----------

# MAGIC %md Using the inline function as show above is great if we just want to flatten our data set but more typically we wish to select just a few fields from the array.  We could create a query like the one above as a nested query and in the higher-level SELECT statement grab the rows we want but a more succinct way to tackle this is just to merge the original and exploded array using a lateral view.

# COMMAND ----------

# MAGIC %sql 
# MAGIC 
# MAGIC select 
# MAGIC     a.executionTime,
# MAGIC     b.*
# MAGIC from stations a
# MAGIC lateral view inline(a.stationBeanList) b

# COMMAND ----------

# MAGIC %md The result of the SQL query is identical to the SQL query that came before it.  But by writing this as a lateral view, we can very succinctly address fields in the expanded array:

# COMMAND ----------

# MAGIC %sql
# MAGIC 
# MAGIC select 
# MAGIC     a.executionTime,
# MAGIC     b.id,
# MAGIC     b.stationName,
# MAGIC     b.availableBikes,
# MAGIC     b.availableDocks,
# MAGIC     b.totalDocks
# MAGIC from stations a
# MAGIC lateral view inline(a.stationBeanList) b 

# COMMAND ----------

# MAGIC %md Not using the lateral view syntax, the previous query would have to be written as follows:

# COMMAND ----------

# MAGIC %sql 
# MAGIC 
# MAGIC select 
# MAGIC     x.executionTime,
# MAGIC     x.id,
# MAGIC     x.stationName,
# MAGIC     x.availableBikes,
# MAGIC     x.availableDocks,
# MAGIC     x.totalDocks
# MAGIC from (
# MAGIC     select 
# MAGIC         a.executionTime,
# MAGIC         inline(a.stationBeanList)
# MAGIC     from stations a
# MAGIC     ) x

# COMMAND ----------

# MAGIC %md If you are curious as to how the last few queries could be written with the programmatic SQL API, it doesn't have an inline and lateral view equivalent so the syntax is a little different:

# COMMAND ----------

# programmatic SQL API version of last couple queries

from pyspark.sql.functions import explode

flat = (
  stations
    .select(stations.executionTime, explode(stations.stationBeanList).alias('stationList'))
    .select('executionTime', 'stationList.*')
  )

display(
  flat.select('executionTime', 'id', 'stationName', 'availableBikes', 'availableDocks', 'totalDocks')
  )

# COMMAND ----------

# MAGIC %md There is one last thing to note.  While we have been using LATERAL VIEWS and EXPLODE to access all the data in the array, it's important to remember that JSON arrays are ordered.  With this in mind, you can access individual members of an array using a familiar syntax:
# MAGIC 
# MAGIC **NOTE** Arrays in SparkSQL do not recognize negative values as working from the tail of the array.  As a result, you must use the **size()** function to retrieve the count of elements in the array and subtract 1 from it to locate the last array element.

# COMMAND ----------

# MAGIC %sql --retrieve the first and last stations in the station list
# MAGIC 
# MAGIC SELECT
# MAGIC   stationBeanList[0]['stationName'] as firstStation,
# MAGIC   stationBeanList[1]['stationName'] as secondStation,
# MAGIC   stationBeanList[2]['stationName'] as thirdStation,
# MAGIC   stationBeanList[size(stationBeanList)-1]['stationName'] as lastStation
# MAGIC FROM stations

# COMMAND ----------

# programmatic SQL API of last query
from pyspark.sql.functions import size

display(
  stations
    .select(
      stations.stationBeanList[0].stationName.alias('firstStation'),
      stations.stationBeanList[1].stationName.alias('secondStation'),
      stations.stationBeanList[2].stationName.alias('thirdStation'),
      stations.stationBeanList[ size(stations.stationBeanList)-1 ].stationName.alias('lastStation')
      )
)

# COMMAND ----------

# MAGIC %md ####Try It Yourself
# MAGIC 
# MAGIC Consider the following scenarios.  Write a simple block of code to answer the question(s) associated with each.  The answer to each question is provided so that your challenge is to come up with code that is logically sound and produces the required result. Code samples answering each scenario are provided by scrolling down to the bottom of the notebook.

# COMMAND ----------

# MAGIC %md ####Scenario 1
# MAGIC 
# MAGIC NOAA provides information on various weather collection stations as part of its HOMR service. You can extract JSON containing info on all the stations it tracks as is shown in the cell below.
# MAGIC 
# MAGIC Using the homr_stations temporary view generated by the cell below, write a SQL statement leveraging a lateral view to extract the header data for all stations with a preferred name that starts with 'DALLAS'.

# COMMAND ----------

from urllib import request as url 

# retrieve json data from website
request = url.Request('https://www.ncdc.noaa.gov/homr/services/station/search?headersOnly=true&state=TX')
response = url.urlopen(request)

# convert to rdd (making sure to convert bytes to UTF-8 string)
json_rdd = sc.parallelize( [response.read().decode('utf-8').strip()] )

# your scenario 2 code here

# convert rdd to dataframe
homr_stations = spark.read.json( json_rdd )
homr_stations.createOrReplaceTempView('homr_stations')

print(response.read().decode('utf-8'))

# COMMAND ----------

# your scenario 1 code here

# COMMAND ----------

# MAGIC %md ####Answers (scroll down)
# MAGIC <br></p> 
# MAGIC <br></p> 
# MAGIC <br></p> 
# MAGIC <br></p> 
# MAGIC <br></p> 
# MAGIC <br></p> 
# MAGIC <br></p> 
# MAGIC <br></p> 
# MAGIC <br></p> 
# MAGIC <br></p> 
# MAGIC <br></p> 
# MAGIC <br></p> 
# MAGIC <br></p> 
# MAGIC <br></p> 
# MAGIC <br></p> 
# MAGIC <br></p> 
# MAGIC <br></p> 
# MAGIC <br></p> 
# MAGIC <br></p>

# COMMAND ----------

# MAGIC %sql -- scenario 1 code
# MAGIC 
# MAGIC SELECT
# MAGIC   b.header.*
# MAGIC FROM homr_stations a
# MAGIC LATERAL VIEW inline(a.stationCollection.stations) b
# MAGIC WHERE b.header.preferredName RLIKE 'DALLAS.*'

# COMMAND ----------

